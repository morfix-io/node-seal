// import { Seal, getLibrary } from '../../target/wasm'
// import { Encryptor } from '../../components'

// let seal,
//   parms,
//   context,
//   keyGenerator,
//   publicKey,
//   secretKey,
//   decryptor,
//   EncryptorObject = null
// beforeAll(async () => {
//   seal = await Seal()
//   const lib = getLibrary()
//   EncryptorObject = Encryptor(lib)(seal)

//   parms = seal.EncryptionParameters(seal.SchemeType.BFV)
//   parms.setPolyModulusDegree(4096)
//   parms.setCoeffModulus(
//     seal.CoeffModulus.BFVDefault(4096, seal.SecurityLevel.tc128)
//   )
//   parms.setPlainModulus(seal.PlainModulus.Batching(4096, 20))
//   context = seal.Context(parms, true, seal.SecurityLevel.tc128)
//   keyGenerator = seal.KeyGenerator(context)
//   publicKey = keyGenerator.publicKey()
//   secretKey = keyGenerator.secretKey()
//   decryptor = seal.Decryptor(context, secretKey)
// })

// describe('Encryptor', () => {
//   test('It should be a factory', () => {
//     expect(EncryptorObject).toBeDefined()
//     expect(typeof EncryptorObject.constructor).toBe('function')
//     expect(EncryptorObject).toBeInstanceOf(Object)
//     expect(EncryptorObject.constructor).toBe(Function)
//     expect(EncryptorObject.constructor.name).toBe('Function')
//   })
//   test('It should construct an instance', () => {
//     const Constructor = jest.fn(EncryptorObject)
//     Constructor(context, publicKey)
//     expect(Constructor).toBeCalledWith(context, publicKey)
//   })
//   test('It should construct an instance with a secretKey', () => {
//     const Constructor = jest.fn(EncryptorObject)
//     Constructor(context, publicKey, secretKey)
//     expect(Constructor).toBeCalledWith(context, publicKey, secretKey)
//   })
//   test('It should fail to construct an instance', () => {
//     const newParms = seal.EncryptionParameters(seal.SchemeType.BFV)
//     newParms.setPolyModulusDegree(2048)
//     newParms.setCoeffModulus(
//       seal.CoeffModulus.BFVDefault(2048, seal.SecurityLevel.tc128)
//     )
//     newParms.setPlainModulus(seal.PlainModulus.Batching(2048, 20))
//     const newContext = seal.Context(newParms)
//     const newKeyGenerator = seal.KeyGenerator(newContext)
//     const newPublicKey = newKeyGenerator.publicKey()

//     const Constructor = jest.fn(EncryptorObject)
//     expect(() => Constructor(context, newPublicKey)).toThrow()
//     expect(Constructor).toBeCalledWith(context, newPublicKey)
//   })
//   test('It should have properties', () => {
//     const item = EncryptorObject(context, publicKey)
//     // Test properties
//     expect(item).toHaveProperty('instance')
//     expect(item).toHaveProperty('unsafeInject')
//     expect(item).toHaveProperty('delete')
//     expect(item).toHaveProperty('encrypt')
//     expect(item).toHaveProperty('encryptSymmetric')
//   })
//   test('It should have an instance', () => {
//     const item = EncryptorObject(context, publicKey)
//     expect(item.instance).toBeDefined()
//   })
//   test('It should inject', () => {
//     const item = EncryptorObject(context, publicKey)
//     const newItem = EncryptorObject(context, publicKey)
//     newItem.delete()
//     const spyOn = jest.spyOn(newItem, 'unsafeInject')
//     newItem.unsafeInject(item.instance)
//     expect(spyOn).toHaveBeenCalledWith(item.instance)
//     expect(newItem.instance).toEqual(item.instance)
//   })
//   test('It should delete the old instance and inject', () => {
//     const item = EncryptorObject(context, publicKey)
//     const newItem = EncryptorObject(context, publicKey)
//     const spyOn = jest.spyOn(newItem, 'unsafeInject')
//     newItem.unsafeInject(item.instance)
//     expect(spyOn).toHaveBeenCalledWith(item.instance)
//     expect(newItem.instance).toEqual(item.instance)
//   })
//   test("It should delete it's instance", () => {
//     const item = EncryptorObject(context, publicKey)
//     const spyOn = jest.spyOn(item, 'delete')
//     item.delete()
//     expect(spyOn).toHaveBeenCalled()
//     expect(item.instance).toBeNull()
//     expect(() => item.encrypt()).toThrow(TypeError)
//   })
//   test('It should skip deleting twice', () => {
//     const item = EncryptorObject(context, publicKey)
//     item.delete()
//     const spyOn = jest.spyOn(item, 'delete')
//     item.delete()
//     expect(spyOn).toHaveBeenCalled()
//     expect(item.instance).toBeNull()
//     expect(() => item.decrypt()).toThrow(TypeError)
//   })
//   test('It should encrypt a plaintext to a destination cipher', () => {
//     const item = EncryptorObject(context, publicKey)
//     const encoder = seal.BatchEncoder(context)
//     const arr = Int32Array.from({ length: encoder.slotCount }).fill(5)
//     const plain = seal.PlainText()
//     const cipher = seal.CipherText()
//     encoder.encode(arr, plain)
//     const spyOn = jest.spyOn(item, 'encrypt')
//     item.encrypt(plain, cipher)
//     expect(spyOn).toHaveBeenCalledWith(plain, cipher)
//     const plainResult = decryptor.decrypt(cipher)
//     const decoded = encoder.decode(plainResult, true)
//     expect(decoded).toEqual(arr)
//   })
//   test('It should encrypt a plaintext and return a cipher', () => {
//     const item = EncryptorObject(context, publicKey)
//     const encoder = seal.BatchEncoder(context)
//     const arr = Int32Array.from({ length: encoder.slotCount }).fill(5)
//     const plain = seal.PlainText()
//     encoder.encode(arr, plain)
//     const spyOn = jest.spyOn(item, 'encrypt')
//     const cipher = item.encrypt(plain)
//     expect(spyOn).toHaveBeenCalledWith(plain)
//     expect(cipher).toBeDefined()
//     expect(typeof cipher.constructor).toBe('function')
//     expect(cipher).toBeInstanceOf(Object)
//     expect(cipher.constructor).toBe(Object)
//     expect(cipher.instance.constructor.name).toBe('Ciphertext')
//     const plainResult = decryptor.decrypt(cipher)
//     const decoded = encoder.decode(plainResult, true)
//     expect(decoded).toEqual(arr)
//   })
//   test('It should symmetrically encrypt a plaintext to a destination cipher', () => {
//     const item = EncryptorObject(context, publicKey, secretKey)
//     const encoder = seal.BatchEncoder(context)
//     const arr = Int32Array.from({ length: encoder.slotCount }).fill(5)
//     const plain = seal.PlainText()
//     const cipher = seal.CipherText()
//     encoder.encode(arr, plain)
//     const spyOn = jest.spyOn(item, 'encryptSymmetric')
//     item.encryptSymmetric(plain, cipher)
//     expect(spyOn).toHaveBeenCalledWith(plain, cipher)
//     const plainResult = decryptor.decrypt(cipher)
//     const decoded = encoder.decode(plainResult, true)
//     expect(decoded).toEqual(arr)
//   })
//   test('It should symmetrically encrypt a plaintext and return a cipher', () => {
//     const item = EncryptorObject(context, publicKey, secretKey)
//     const encoder = seal.BatchEncoder(context)
//     const arr = Int32Array.from({ length: encoder.slotCount }).fill(5)
//     const plain = seal.PlainText()
//     encoder.encode(arr, plain)
//     const spyOn = jest.spyOn(item, 'encryptSymmetric')
//     const cipher = item.encryptSymmetric(plain)
//     expect(spyOn).toHaveBeenCalledWith(plain)
//     expect(cipher).toBeDefined()
//     expect(typeof cipher.constructor).toBe('function')
//     expect(cipher).toBeInstanceOf(Object)
//     expect(cipher.constructor).toBe(Object)
//     expect(cipher.instance.constructor.name).toBe('Ciphertext')
//     const cipherTest = seal.CipherText()
//     cipherTest.load(context, cipher.save())
//     const plainResult = decryptor.decrypt(cipherTest)
//     const decoded = encoder.decode(plainResult, true)
//     expect(decoded).toEqual(arr)
//   })
//   test('It should fail to encrypt', () => {
//     const item = EncryptorObject(context, publicKey)
//     const encoder = seal.BatchEncoder(context)
//     const arr = Int32Array.from({ length: encoder.slotCount }).fill(0)
//     const plain = seal.PlainText()
//     encoder.encode(arr, plain)
//     const spyOn = jest.spyOn(item, 'encrypt')
//     expect(() => item.encrypt()).toThrow()
//     expect(spyOn).toHaveBeenCalledWith()
//   })
//   test('It should fail to symmetrically encrypt', () => {
//     const item = EncryptorObject(context, publicKey, secretKey)
//     const encoder = seal.BatchEncoder(context)
//     const arr = Int32Array.from({ length: encoder.slotCount }).fill(0)
//     const plain = seal.PlainText()
//     encoder.encode(arr, plain)
//     const spyOn = jest.spyOn(item, 'encryptSymmetric')
//     expect(() => item.encryptSymmetric()).toThrow()
//     expect(spyOn).toHaveBeenCalledWith()
//   })
//   test('It should symmetrically encrypt a plaintext and return a serializable ciphertext', () => {
//     const item = EncryptorObject(context, publicKey, secretKey)
//     const encoder = seal.BatchEncoder(context)
//     const arr = Int32Array.from({ length: encoder.slotCount }).fill(5)
//     const plain = seal.PlainText()
//     encoder.encode(arr, plain)
//     const spyOn = jest.spyOn(item, 'encryptSymmetricSerializable')
//     const serialized = item.encryptSymmetricSerializable(plain)
//     expect(spyOn).toHaveBeenCalledWith(plain)
//     expect(serialized).toBeDefined()
//     expect(typeof serialized.constructor).toBe('function')
//     expect(serialized).toBeInstanceOf(Object)
//     expect(serialized.constructor).toBe(Object)
//     expect(serialized.instance.constructor.name).toBe(
//       'Serializable$Ciphertext$'
//     )
//     const cipher = seal.CipherText()
//     cipher.load(context, serialized.save())
//     const plainResult = decryptor.decrypt(cipher)
//     const decoded = encoder.decode(plainResult, true)
//     expect(decoded).toEqual(arr)
//   })
//   test('It should fail to symmetrically encrypt and return a serializable ciphertext', () => {
//     const item = EncryptorObject(context, publicKey, secretKey)
//     const encoder = seal.BatchEncoder(context)
//     const arr = Int32Array.from({ length: encoder.slotCount }).fill(0)
//     const plain = seal.PlainText()
//     encoder.encode(arr, plain)
//     const spyOn = jest.spyOn(item, 'encryptSymmetricSerializable')
//     expect(() => item.encryptSymmetricSerializable()).toThrow()
//     expect(spyOn).toHaveBeenCalledWith()
//   })
// })
